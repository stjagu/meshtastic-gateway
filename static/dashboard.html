<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Mesh Gateway Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
/* --------------------------------------------------
   GLOBAL
-------------------------------------------------- */
body {
    margin: 0;
    background: #1a1a1a;
    color: #eee;
    font-family: Arial, sans-serif;
    padding-bottom: 70px;
}

/* --------------------------------------------------
   MAIN GRID (A-LAYOUT)
   Map left big ‚Ä¢ panels right stacked
-------------------------------------------------- */
.grid {
    display: grid;
    grid-template-columns: 1fr 350px;
    grid-template-rows: 1fr;
    height: calc(100vh - 52px);
    gap: 12px;
    padding: 10px;
    padding-bottom: 62px;
    box-sizing: border-box;
}



/* MAP */
#mapCard {
    background: #222;
    border-radius: 8px;
    padding: 10px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

/* RIGHT PANELS (A-LAYOUT) */
#rightPanels {
  display: grid;
  grid-template-rows: 1fr 1.5fr 2fr; /* relative, not viewport-based */
  gap: 12px;
  min-height: 0;
}

.panel {
    background: #111;
    border-radius: 8px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    min-height: 0;
    
}

.scroll-area {
    flex: 1;
    overflow-y: auto;
    min-height: 0;
}

/* --------------------------------------------------
   MESSAGE COLORS (A-VERSION)
-------------------------------------------------- */
.msg-text  { color: #6aff6a; }   /* green */
.msg-gps   { color: #4af0ff; }   /* cyan */
.msg-tele  { color: #ffb347; }   /* orange */
.msg-alert { color: #ff6a6a; }   /* red */
.msg-other { color: #bbb; }      /* grey */


/* -----------------------------
   Message rows
----------------------------- */
.msg-line {
    padding: 4px 0;
    margin-bottom: 4px;
    line-height: 1.35;
    border-bottom: 1px solid rgba(255,255,255,0.06);
}

.msg-line:last-child {
    border-bottom: none;
}

/* --------------------------------------------------
   DRAWERS
-------------------------------------------------- */
.drawer {
    position: fixed;
    right: -380px;
    top: 0;
    width: 380px;
    height: 100vh;
    background: #111;
    border-left: 2px solid #333;
    color: #eee;
    transition: right .3s ease;
    z-index: 9999;
    display: flex;
    flex-direction: column;
}
.drawer.open { right: 0; }

.drawer-header {
    padding: 12px;
    background: #1b1b1b;
    border-bottom: 2px solid #333;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
}

.drawer-content {
    padding: 12px;
    overflow-y: auto;
    flex: 1;
}

/* --------------------------------------------------
   SEND BAR
-------------------------------------------------- */
#sendBox {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 52px;
    background: #0f0f0f;
    border-top: 1px solid #333;
    display: flex;
    gap: 8px;
    align-items: center;
    padding: 6px 12px;
    z-index: 99999;
}

#sendInput,
#sendTarget,
#sendBtn {
    height: 38px;
}

#sendInput {
    flex: 1;
    background: #1a1a1a;
    color: white;
    border-radius: 5px;
    border: 1px solid #444;
    padding: 0 10px;
}

#sendBtn {
    background: #0078ff;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 0 16px;
}

/* -------------------------------
    Channels
    ------------------------------ */
    .channel-row {
  padding: 6px;
  border-bottom: 1px solid #333;
  cursor: pointer;
}
.channel-row:hover { background: #222; }
.channel-row.selected {
  outline: 2px solid #0078ff;
  background: #1b2a44;
}

#terminalPanel {
  display: flex;
  flex-direction: column;
  min-height: 0;
}

#terminal {
  flex: 1;
  overflow-y: auto;
  min-height: 0;   /* CRITICAL: allows flex scrolling */
}

#terminalPanel {
  min-height: 0;
  display: flex;
  flex-direction: column;
}

#terminal {
  flex: 1;
  min-height: 0;
  overflow-y: auto;
}

#terminalControls {
  flex-shrink: 0;
}



</style>
</head>
<body>

<div class="grid">

    <!-- MAP -->
    <div id="mapCard">
        <h2>üìç Live Map</h2>
        <iframe id="mapframe" src="/map"
            style="width:100%; height:100%; border:none; border-radius:6px;">
        </iframe>
    </div>

    <!-- RIGHT PANELS -->
    <div id="rightPanels">

        <div id="channelsPanel" class="panel">
            <h2>Channels</h2>
            <div id="channelList" class="scroll-area"></div>
        </div>

        <div id="messagesPanel" class="panel">
            <h2>Messages</h2>
            <div id="messages" class="scroll-area"></div>
        </div>

<div id="terminalPanel" class="panel">
  <h2>Terminal</h2>

  <div id="terminal" class="scroll-area" style="font-family: monospace; font-size: 12px;"></div>

  <div id="terminalControls" style="display:flex; gap:8px; margin-top:8px;">
    <input id="terminalInput"
           placeholder="Type command‚Ä¶ (Enter to send)"
           style="flex:1; height:34px; background:#0b0b0b; color:#eee; border:1px solid #333; border-radius:6px; padding:0 10px; font-family:monospace;" />
    <button id="terminalSendBtn"
            onclick="sendTerminal()"
            style="height:34px; padding:0 14px; border:0; border-radius:6px; background:#0078ff; color:white;">
      Send
    </button>
  </div>

  <div id="nodeList" style="display:none;"></div>
</div>

  <!-- keep loadNodes() happy -->
  <div id="nodeList" style="display:none;"></div>
</div>

    
</div>

<!-- DRAWERS -->
<div id="drawer" class="drawer">
    <div class="drawer-header">
        <span id="drawerTitle">Node Details</span>
        <button onclick="closeDrawer()">‚úñ</button>
    </div>
    <div id="drawerContent" class="drawer-content"></div>
</div>

<div id="channelDrawer" class="drawer">
    <div class="drawer-header">
        <span id="channelDrawerTitle">Channel Details</span>
        <button onclick="closeChannelDrawer()">‚úñ</button>
    </div>
    <div id="channelDrawerContent" class="drawer-content"></div>
</div>

<!-- SEND BAR -->
<div id="sendBox">
    <select id="sendTarget"><option value="">Broadcast</option></select>
    <input id="sendInput" placeholder="Send message‚Ä¶">
    <button id="sendBtn" onclick="sendMessage()">Send</button>
    <div id="replyBadge" style="display:none; color:#bbb; font-size:12px; margin-left:6px;"></div>
</div>

<script>
// --------------------------------------------------
// GLOBALS
// --------------------------------------------------
let globalNodes = {};
let selectedChannel = null;


// --------------------------------------------------
// REPLY MODE (must be defined before loadMessages)
// --------------------------------------------------
let replyMode = null; // { to:"165", from:"!e4044dc8", channel:0 } or null

function setReplyMode(toValue, fromLabel, channel) {
  replyMode = {
    to: String(toValue || ""),
    from: fromLabel || "",
    channel: channel ?? null
  };

  const sel = document.getElementById("sendTarget");
  if (sel && replyMode.to) sel.value = replyMode.to;

  const badge = document.getElementById("replyBadge");
  if (badge) {
    badge.style.display = "block";
    badge.textContent = `Replying to ${replyMode.from || replyMode.to} (Esc to clear)`;
  }

  const input = document.getElementById("sendInput");
  if (input) input.focus();
}

function clearReplyMode() {
  replyMode = null;

  const badge = document.getElementById("replyBadge");
  if (badge) badge.style.display = "none";

  const sel = document.getElementById("sendTarget");
  if (sel) sel.value = "";
}

window.addEventListener("keydown", (e) => {
  if (e.key === "Escape") clearReplyMode();
});

// --------------------------------------------------
// MESSAGE CLASSIFIER (restored A-version colors)
// --------------------------------------------------
function classifyMessage(msg) {
    const t = msg.toLowerCase();
    if (t.includes("[gps]")) return "msg-gps";
    if (t.includes("[telemetry]") || t.includes("[env]")) return "msg-tele";
    if (t.includes("alert") || t.includes("fail") || t.includes("error")) return "msg-alert";
    return "msg-text";
}

// --------------------------------------------------
// Terminal
// --------------------------------------------------
function addTerminalLine(line) {
  const term = document.getElementById("terminal");
  if (!term) return;

  const el = document.createElement("div");
  el.textContent = line;
  term.prepend(el);

  while (term.childNodes.length > 250) term.removeChild(term.lastChild);
}

function startTerminalSSE() {
  const ev = new EventSource("/events");

  ev.onmessage = (evt) => {
    try {
      const data = JSON.parse(evt.data);

      if (data.type === "packet") {
        const pkt = data.packet || {};
        const from = pkt.fromId || pkt.from || "?";
        const decoded = pkt.decoded || {};
        const port = decoded.portnum || "";
        const text = decoded.text || "";
        const pos = decoded.position;

        if (port === "TEXT_MESSAGE_APP" && text) {
          addTerminalLine(`${from} [TEXT] ${text}`);
        } 
        else if (port === "POSITION_APP" && pos) {
          const lat = pos.latitude ?? (pos.latitudeI ? pos.latitudeI / 1e7 : "?");
          const lon = pos.longitude ?? (pos.longitudeI ? pos.longitudeI / 1e7 : "?");
          addTerminalLine(`${from} [GPS] ${lat}, ${lon}`);
        } 
        else {
          addTerminalLine(`${from} ${port}`);
        }
      }

    } catch (e) {
      // swallow malformed SSE packets safely
      console.warn("Terminal parse error", e);
    }
  };

  ev.onerror = () => {
    addTerminalLine("[SSE disconnected]");
  };
}

// --------------------------------------------------
// Terminal Input
// --------------------------------------------------
function appendTerminalLine(text) {
  const term = document.getElementById("terminal");
  if (!term) return;

  const line = document.createElement("div");
  line.style.whiteSpace = "pre-wrap";
  line.textContent = text;
  term.prepend(line);

  while (term.childNodes.length > 300) term.removeChild(term.lastChild);
}

async function sendTerminal() {
  const inp = document.getElementById("terminalInput");
  if (!inp) return;

  const raw = inp.value.trim();
  if (!raw) return;

  // Defaults
  let to = ""; // broadcast
  let channel = (selectedChannel != null) ? Number(selectedChannel) : 0;

  // Parse /dm and /ch in any order
  const parts = raw.split(/\s+/);
  const msgParts = [];

  for (let i = 0; i < parts.length; i++) {
    const p = parts[i];

    if (p === "/dm" && parts[i + 1]) {
      to = parts[i + 1];
      i++;
      continue;
    }

    if ((p === "/ch" || p === "/channel") && parts[i + 1]) {
      const maybe = parseInt(parts[i + 1], 10);
      if (!isNaN(maybe)) channel = maybe;
      i++;
      continue;
    }

    if (p === "/reply") {
      const sel = document.getElementById("sendTarget");
      if (sel && sel.value) to = sel.value;
      continue;
    }

    msgParts.push(p);
  }

  const text = msgParts.join(" ").trim();
  if (!text) {
    appendTerminalLine("(no message text)");
    return;
  }

  appendTerminalLine(`mesh> ${raw}`);
  appendTerminalLine(`‚Üí to=${to || "broadcast"}  ch=${channel}  text="${text}"`);

  try {
    const r = await fetch("/api/send", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text, to, channel })
    });

    const res = await r.json();
    if (res.status === "sent") {
      appendTerminalLine("‚úì sent");
      inp.value = "";
      inp.focus();
    } else {
      appendTerminalLine(`‚úó send failed: ${res.error || "unknown error"}`);
    }
  } catch (e) {
    appendTerminalLine(`‚úó send failed: ${e}`);
  }
}

// Enter to send while in terminal input
window.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && document.activeElement?.id === "terminalInput") {
    e.preventDefault();
    sendTerminal();
  }
});

// --------------------------------------------------
// LOAD MESSAGES (format + colors + click-to-reply + focus map)
// --------------------------------------------------
async function loadMessages() {
  try {
    const r = await fetch("/api/messages");
    const msgs = await r.json();

    const box = document.getElementById("messages");
    if (!box) return; // safety
    box.innerHTML = "";

    const filtered = msgs.filter(m => {
      if (selectedChannel === null) return true;
      const chan = m.channel ?? m.channelIndex ?? 0;
      return Number(chan) === Number(selectedChannel);
    });

    filtered.slice(0, 120).forEach(m => {
      const div = document.createElement("div");
      div.className = "msg-line " + classifyMessage(m.message || "");
      div.innerHTML = `[${m.timestamp}] <b>${m.from}</b>: ${m.message}`;

      div.style.cursor = "pointer";
      div.title = "Click to reply";

      div.onclick = () => {
        const fromLabel = m.from; // e.g. "!e4044dc8"
        const chan = m.channel ?? m.channelIndex ?? null;

        let toNum = null;
        let nodeObj = null;

        // map "!xxxx" -> node.num AND grab node object for focus/drawer
        for (const k in globalNodes) {
          const n = globalNodes[k];
          const uid = n?.user?.id;
          if (uid && uid === fromLabel) {
            toNum = n.num;
            nodeObj = n;
            break;
          }
        }

        // fallback if it's already numeric
        if (toNum == null) {
          const maybeNum = parseInt(fromLabel, 10);
          if (!isNaN(maybeNum)) toNum = maybeNum;
        }

        // focus + drawer (only if functions exist)
        if (nodeObj) {
          if (typeof focusNodeOnMap === "function") focusNodeOnMap(nodeObj);
          if (typeof showNodeDrawer === "function") showNodeDrawer(nodeObj);
        } else if (toNum != null) {
          // try to find node by num
          for (const k in globalNodes) {
            const n = globalNodes[k];
            if (n?.num != null && Number(n.num) === Number(toNum)) {
              if (typeof focusNodeOnMap === "function") focusNodeOnMap(n);
              if (typeof showNodeDrawer === "function") showNodeDrawer(n);
              break;
            }
          }
        }

        // reply mode
        if (typeof setReplyMode === "function") {
          if (toNum != null) setReplyMode(toNum, fromLabel, chan);
          else setReplyMode("", fromLabel, chan);
        }
      };

      box.appendChild(div);
    });

    if (selectedChannel !== null && filtered.length === 0) {
      box.innerHTML = `<div style="opacity:.7;">No messages found for channel ${selectedChannel} in current server LIMIT.</div>`;
    }
  } catch (err) {
    console.error("loadMessages:", err);
  }
}

// --------------------------------------------------
// LOAD NODES
// --------------------------------------------------
async function loadNodes() {
  try {
    const r = await fetch("/api/nodes");
    globalNodes = await r.json();

    const box = document.getElementById("nodeList");
    if (box) box.innerHTML = "";

    for (const key in globalNodes) {
      const n = globalNodes[key];
      const user = n.user || {};

      const name =
        user.longName ||
        user.shortName ||
        user.id ||
        n.num ||
        "Node";

      if (box) {
        const row = document.createElement("div");
        row.className = "node-row";
        row.style.padding = "6px";
        row.style.borderBottom = "1px solid #333";
        row.style.cursor = "pointer";

        row.innerHTML = `
          <div class="node-name">${name}</div>
          <div class="node-meta" style="opacity:.7; font-size:12px;">
            SNR ${n.snr ?? "?"} | RSSI ${n.rssi ?? "?"} | Hops ${n.hops ?? "?"}
          </div>
        `;

        row.onclick = () => {
          showNodeDrawer(n);
          focusNodeOnMap(n);
          const target = document.getElementById("sendTarget");
          if (target) target.value = n.num ?? user.id ?? "";
        };

        box.appendChild(row);
      }
    }

    // ---- update send dropdown (reuse variable name ONCE) ----
    const sendSel = document.getElementById("sendTarget");
    if (!sendSel) return;

    const old = sendSel.value;
    sendSel.innerHTML = `<option value="">Broadcast</option>`;

    for (const key in globalNodes) {
      const n = globalNodes[key];
      if (n.num) sendSel.innerHTML += `<option value="${n.num}">${n.num}</option>`;
    }

    if (old) sendSel.value = old;

  } catch (err) {
    console.error("loadNodes:", err);
  }
}

// --------------------------------------------------
// LOAD CHANNELS (simple restored list)
// --------------------------------------------------
async function loadChannels() {
    try {
        const r = await fetch("/api/channels");
        const chans = await r.json();

        const box = document.getElementById("channelList");
        box.innerHTML = "";

        chans.forEach(ch => {
            const idx = ch.index ?? ch.id ?? 0;

            const name =
                (ch.name && ch.name.trim() !== "")
                    ? ch.name
                    : (idx === 0 || ch.primary ? "Primary Channel" : `Channel ${idx}`);

            const row = document.createElement("div");
            row.className = "channel-row";

            // keep highlight in sync on re-render
            if (selectedChannel !== null && Number(selectedChannel) === Number(idx)) {
                row.classList.add("selected");
            }

            row.innerHTML = `
                <div><b>${(idx === 0 || ch.primary) ? "‚≠ê " : ""}${name}</b>
                    <span style="opacity:.7; font-size:11px;">(#${idx})</span>
                </div>
                <div style="opacity:.7; font-size:12px;">
                    ${(ch.psk && ch.psk !== "AQ==") ? "Encrypted" : "Default"} ¬∑
                    ${ch.uplinkEnabled ? "Uplink" : "No Uplink"} ¬∑
                    ${ch.downlinkEnabled ? "Downlink" : "No Downlink"}
                </div>
            `;
            
            row.onclick = () => {
                // toggle off if clicking same channel again
                if (selectedChannel !== null && Number(selectedChannel) === Number(idx)) {
                    selectedChannel = null;
                    document.querySelectorAll(".channel-row").forEach(r => r.classList.remove("selected"));
                } else {
                    selectedChannel = idx;
                    document.querySelectorAll(".channel-row").forEach(r => r.classList.remove("selected"));
                    row.classList.add("selected");
                }

                // optional drawer if you have it
                if (typeof showChannelDrawer === "function") showChannelDrawer(ch);

                // refresh message list using the new filter
                loadMessages();
            };

            box.appendChild(row);
        });

    } catch (err) {
        console.error("loadChannels:", err);
    }
}

// --------------------------------------------------
// DRAWERS
// --------------------------------------------------
function openDrawer() {
    document.getElementById("drawer").classList.add("open");
}
function closeDrawer() {
    document.getElementById("drawer").classList.remove("open");
}

function openChannelDrawer() {
    document.getElementById("channelDrawer").classList.add("open");
}
function closeChannelDrawer() {
    document.getElementById("channelDrawer").classList.remove("open");
}

function showNodeDrawer(node) {
    openDrawer();

    const user = node.user || {};
    const pos = node.position || {};

    const name =
        user.longName ||
        user.shortName ||
        user.id ||
        node.num;

    const lat = pos.latitude ?? (pos.latitudeI ? pos.latitudeI / 1e7 : "?");
    const lon = pos.longitude ?? (pos.longitudeI ? pos.longitudeI / 1e7 : "?");

    document.getElementById("drawerTitle").innerText = name;

    document.getElementById("drawerContent").innerHTML = `
        <div><b>ID:</b> ${user.id ?? node.num}</div>
        <div><b>Short:</b> ${user.shortName ?? ""}</div>
        <div><b>Long:</b> ${user.longName ?? ""}</div>
        <hr>
        <div><b>GPS:</b> ${lat}, ${lon}</div>
        <div><b>Last Heard:</b> ${node.lastHeard ?? ""}</div>
        <hr>
        <div><b>SNR:</b> ${node.snr ?? "?"}</div>
        <div><b>RSSI:</b> ${node.rssi ?? "?"}</div>
    `;
}

// --------------------------------------------------
// MAP COMMUNICATION
// --------------------------------------------------
function focusNodeOnMap(node) {
    const pos = node.position || {};
    const lat = pos.latitude ?? (pos.latitudeI ? pos.latitudeI / 1e7 : null);
    const lon = pos.longitude ?? (pos.longitudeI ? pos.longitudeI / 1e7 : null);
    if (lat == null || lon == null) return;

    document.getElementById("mapframe").contentWindow.postMessage({
        type: "focus",
        lat,
        lon
    }, "*");
}

// ----------------------------------------------------------
// RECEIVE SELECTION FROM MAP  (accept numeric OR string IDs)
// ----------------------------------------------------------
window.addEventListener("message", (event) => {
    const msg = event.data;
    if (!msg || msg.type !== "selectNode") return;

    const id = msg.node;
    if (!id) return;

    let node = null;

    for (const key in globalNodes) {
        const n = globalNodes[key];
        const user = n.user || {};

        // match either numeric radio num or user.id string
        if (
            (n.num != null && String(n.num) === String(id)) ||
            (user.id && String(user.id) === String(id))
        ) {
            node = n;
            break;
        }
    }

    if (!node) {
        console.warn("No node matched selectNode:", id);
        return;
    }

    // open drawer, focus map, set send target
    showNodeDrawer(node);
    focusNodeOnMap(node);

    const sel = document.getElementById("sendTarget");
    sel.value = node.num ?? id;
});

// --------------------------------------------------
// SEND MESSAGE  (NOW INCLUDES CHANNEL)
// --------------------------------------------------
async function sendMessage() {
  const input = document.getElementById("sendInput");
  const textRaw = input.value.trim();
  const sel = document.getElementById("sendTarget");
  const to = sel.value;

  if (!textRaw) return;

  const channel =
    (replyMode && replyMode.channel != null) ? Number(replyMode.channel) :
    (selectedChannel != null) ? Number(selectedChannel) :
    0;

  // ‚úÖ Key rule:
  // If replying to something that happened on channel 1+,
  // send to the CHANNEL (broadcast), NOT a destinationId DM.
  let sendTo = to;               // default behavior
  let text = textRaw;

  if (replyMode && channel > 0) {
    sendTo = "";                 // broadcast
    // optional: tag so it feels like a reply
    if (replyMode.from) text = `@${replyMode.from} ${textRaw}`;
  }

  try {
    await fetch("/api/send", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text, to: sendTo, channel })
    });

    input.value = "";
  } catch (err) {
    console.error("send:", err);
  }
}


// --------------------------------------------------
// START INTERVAL LOADERS
// --------------------------------------------------
loadMessages();
loadNodes();
loadChannels();
startTerminalSSE();

setInterval(loadMessages, 2000);
setInterval(loadNodes, 4000);
setInterval(loadChannels, 15000);

</script>

</body>
</html>
